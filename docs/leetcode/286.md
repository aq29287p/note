---
title: 286
---

# 286.  
## 解答
1. 創建 queue 把gate 位置放入queue  
2. 遍歷整個 queue 的 上下左右位置 , 若 x or y 超出範圍 or 此次距離 < 上次距離+1 則不做任何事  
3. 反之 此次距離 = 上次距離+1 且 此次位置 放入 queue  


### 實作

:::: code-group
::: code-group-item c++

``` cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        //x 範圍
        const int m = room.size();
        //y 範圍
        const int n = room[0].size();
        //(x,y) 上, 右, 下, 左 
        const vector<int> dirs{0, 1, 0, -1, 0};
        //存放 gate 位置 以及後續位置
        queue<pair<int, int>> q;        
        //遍歷 all x , y 並把gate的(x,y) 放入 q     
        for(int i=0; i<m ; i++)
            for(int j=0; j<n; j++)  
                if(room[i][j]==0)
                    q.emplace(i,j);
        while(!q.empty()){
            const auto [i, j] = q.front();
            q.pop();
            for(int k=0; k<4; k++){
                const int x= i+dirs[k];
                const int y= i+dirs[k+1];
                // x,y 超出邊界 or 此次距離(x,y) 小於 上次距離 (i,j) +1  -> pass 
                if(x==-1||x==m||y==-1||y==n||rooms[x][y] < rooms[i][j] + 1)
                    continue;
                rooms[x][y] = rooms[i][j] + 1;
                q.emplace(x, y);
            }
        }
    }
};
```

:::
::: code-group-item python

``` python

```
::::

### 分析
- 時間複雜度：$\mathcal{O}((m*n)^2)$
第一次遍歷 m*n 元素找到gate  
第二次遍歷gate元素 * 邊界內能走的路~m*n  
- 空間複雜度：$\mathcal{O}(m*n)$
 q= g, g_1, ... space1, space2...  
