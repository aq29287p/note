---
title: 1197
---

# 1197.  
## 解答
1. 起點與終點 形成的矩形 再外擴2格 在這範圍內使用bfs  
2. ![](https://leetcode.jp/wp-content/uploads/2019/11/1-1.png)  
### 實作

:::: code-group
::: code-group-item c++

``` cpp
public int minKnightMoves(int x, int y) {
    int startx=0;
    int starty=0;
    //若 終點x < 0 
    if(x<0){
        //則 起點與終點x座標 右移 |x| 使其皆為正
        startx=-x;
        x=0;
    }
    //若 終點y < 0 
    if(y<0){
        //則 起點與終點y座標 上移 || 使其皆為正
        starty=-y;
        y=0;
    }
    //上下左右
    int dirt[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};
    //起終點 形成的矩形邊界各擴寬2
    startx+=2;
    starty+=2;
    x+=2;
    y+=2;
    //邊界 為最大值+2
    int bcx=Max(startx,x)+2;
    int bcy=Max(starty,y)+2;
    //列隊
    queue<pair<int,int>> q;
    q.push(startx,starty);
    //以造訪過座標
    unordered_set<pair<int,int>> visited{{startx,starty}};
    int res=0;
    while(!q.empty()){
        res++;
        int sz=q.size();
        for(int i=0; i<sz ;i++){
            auto cur= q.front();
            q.pop();
            for(auto d : dirt){
                int nexttx=cur.first+d[0];
                int nextty=cur.second+d[1];
                if(nexttx==x && nextty==y) return res;
                if(nexttx >=0 && nexttx <= bcx && nextty >=0 && nextty <= bcy && !visited.count({nexttx,nextty})){
                    q.push({nexttx,nextty});
                    visited.insert({nexttx,nextty});
                };
            }
        }
    }
    return -1;
};

```

:::
::: code-group-item python

``` python

```
::::

### 分析
- 時間複雜度：$\mathcal{O}(xy)$

- 空間複雜度：$\mathcal{O}(xy)$
