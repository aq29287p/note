---
title: 1009
---

# 1009.  
## 解答
1. n = 0...1...  
2. n xor 0...111... = ans
### 實作

:::: code-group
::: code-group-item c++

``` cpp
class Solution {
public:
    int bitwiseComplement(int n) {
        //bc n = 0
        if(!n) return 1;
        int t =n;
        // int 有 32bit 所以需要 右移 32位元
        // 第一次 右移 1 bit -> 從左邊確定有 2個1
        // 第二次 右移 2 bit -> 確定有 4個1
        // 第三次 右移 4 bit -> 確定有 8個1
        for (int i = 1; i <6 ; i++){
        // t or t往右 2^i 次方
            t= (t>>i) | t;
        }
        // n xor (all 1)
        return n ^ t;
    }
};

```

:::
::: code-group-item python

``` python

```
::::

### 分析
- 時間複雜度：$\mathcal{O}(log{2}{32})$
只需看int 有幾個bit   
- 空間複雜度：$\mathcal{O}(1)$
