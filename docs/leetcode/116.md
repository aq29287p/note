---
title: 116
---

# 116.  
## 解答
1. 創建 queue 一層一層加入node    
2. 使用 父節點的next指針  
### 實作

:::: code-group
::: code-group-item c++

``` cpp
class Solution {
public:
    Node* connect(Node* root) {
        if(root==nullptr) return root;
        //
        queue<Node*> q;
        q.push(root);
         // 外层的 while 循环迭代的是层数
        while(!q.empty()){
            // 记录当前队列大小
            int sz= q.size();
            // 遍历这一层的所有节点
            for(int i=0;i<sz;i++){
                Node* curnode=q.front();
                q.pop();
                //連結
                if(i<sz-1) curnode->next=q.front();
                // 拓展下一层节点
                if(curnode->left!=nullptr) q.push(curnode->left);
                if(curnode->right!=nullptr) q.push(curnode->right);
            }
            
        }
       // 返回根节点
        return root;
    }
}; 

```
### 分析
- 時間複雜度：$\mathcal{O}(n)$  
- 空間複雜度：$\mathcal{O}(n)$
### 實作2
``` cpp
class Solution {
public:
    Node* connect(Node* root) {
        if(root==nullptr) return root;
        Node* leftmost=root;
        //無左節點 則為最後一層
        while(leftmost->left!=nullptr){
            Node* head=leftmost;
            //整層
            while(head!=nullptr){
                //左葉連結右葉
                head->left->next=head->right;
                //右葉連結左葉
                if(head->next!=nullptr) head->right->next=head->next->left;
                //父節往後
                head=head->next;
            }
            //換下一層
            leftmost=leftmost->left;
        }

       // 返回根节点
        return root;
    }
}; 

```

:::
::: code-group-item python

``` python

```
::::

### 分析
- 時間複雜度：$\mathcal{O}(n)$
遍歷n個元素  
- 空間複雜度：$\mathcal{O}(1)$

