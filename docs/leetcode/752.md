---
title: 752
---

# 752.  
## 解答
1. 創建 queue 把gate 位置放入queue  
2. 遍歷整個 queue 的 上下左右位置 , 若 x or y 超出範圍 or 此次距離 < 上次距離+1 則不做任何事  
3. 反之 此次距離 = 上次距離+1 且 此次位置 放入 queue  


### 實作

:::: code-group
::: code-group-item c++

``` cpp
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
        
        if (target == "0000") return 0;
        unordered_set<string> dead(deadends.begin(), deadends.end());
        //bc
        if (dead.count("0000")) return -1;
        //走下一步 數字變化函數
        auto num_next = [](char x) -> char {
            return (x == '0' ? '9' : x - 1);
        };
        //走上一步 數字變化函數
        auto num_prev = [](char x) -> char {
            return (x == '9' ? '0' : x + 1);
        };
        //輸入一組數字 給出所有走一步的數字
        auto get = [&](string& status) -> vector<string>{
            vector<string> ret;
            for(int i=0; i<4 ; i++){
                char num=status[i];
                status[i] = num_prev(num);
                ret.push_back(status);
                status[i] = num_next(num);
                ret.push_back(status);
                
                status[i] = num;
            }
            return ret;  
        };
        queue<pair<string, int>> q;
        q.emplace("0000", 0);
        //檢查是否走過
        unordered_set<string> seen = {"0000"};
        while(!q.empty()){
            auto [status, step] = q.front();
            q.pop();
            //遍歷該次節點所衍伸的下一步
            for (auto&& next_status: get(status)){
                if(!seen.count(next_status) && ! dead.count(next_status)){
                    if (next_status == target){
                        return step + 1;
                    }
                    q.emplace(next_status,step+1);
                    seen.insert(move(next_status));
                }
            }
        }
    return -1;    
    }
};

```
``` cpp
class Solution



```

:::
::: code-group-item python

``` python

```
::::

### 分析
- 時間複雜度：$\mathcal{O}((m*n)^2)$
第一次遍歷 m*n 元素找到gate  
第二次遍歷gate元素 * 邊界內能走的路~m*n  
- 空間複雜度：$\mathcal{O}(m*n)$
 q= g, g_1, ... space1, space2...  
