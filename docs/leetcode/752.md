---
title: 752
---

# 752.  
## 解答
1. 單向BFS by lambda function  
1. 單向BFS 模板  
2. 雙向BFS  
双向 BFS 适用于 <起点> 和 <终点> 都知道的的情况下使用。  
使用双向 BFS 求出最短路径的充要条件是图中不存在长度为奇数的回路（对于一般的位置移动的状态变化，限制只能上、下、左、右邻近位置移动则不存在长度为奇数的回路）。
![](https://raw.githubusercontent.com/aq29287p/note/docs/docs/picture/752.png)


### 實作

:::: code-group
::: code-group-item c++

``` cpp
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
        
        if (target == "0000") return 0;
        unordered_set<string> dead(deadends.begin(), deadends.end());
        //bc
        if (dead.count("0000")) return -1;
        //走下一步 數字變化函數
        auto num_next = [](char x) -> char {
            return (x == '0' ? '9' : x - 1);
        };
        //走上一步 數字變化函數
        auto num_prev = [](char x) -> char {
            return (x == '9' ? '0' : x + 1);
        };
        //輸入一組數字 給出所有走一步的數字
        auto get = [&](string& status) -> vector<string>{
            vector<string> ret;
            for(int i=0; i<4 ; i++){
                char num=status[i];
                status[i] = num_prev(num);
                ret.push_back(status);
                status[i] = num_next(num);
                ret.push_back(status);
                
                status[i] = num;
            }
            return ret;  
        };
        queue<pair<string, int>> q;
        q.emplace("0000", 0);
        //檢查是否走過
        unordered_set<string> seen = {"0000"};
        while(!q.empty()){
            auto [status, step] = q.front();
            q.pop();
            //遍歷該次節點所衍伸的下一步
            for (auto&& next_status: get(status)){
                if(!seen.count(next_status) && ! dead.count(next_status)){
                    if (next_status == target){
                        return step + 1;
                    }
                    q.emplace(next_status,step+1);
                    seen.insert(move(next_status));
                }
            }
        }
    return -1;    
    }
};

```
:::
::: code-group-item c++
``` cpp
class Solution {
public:
  int openLock(vector<string>& deadends, string target) {
    const string start = "0000";
    unordered_set<string> dead(deadends.begin(), deadends.end());
    if (dead.count(start)) return -1;
    if (start == target) return 0;
    
    queue<string> q;
    unordered_set<string> visited{start};
    
    int steps = 0;
    q.push(start);
    while (!q.empty()) {
      ++steps;
      const int size = q.size();
      for (int i = 0; i < size; ++i) {
        const string curr = q.front(); 
        q.pop();
        for (int i = 0; i < 4; ++i)
          for (int j = -1; j <= 1; j += 2) {
            string next = curr;
            //  -'0' 轉成數字 0 ; +j 上下轉動 ; +10 把 -1 轉成 9 ; % 10 保證 0~9 ; + '0' 轉回char
            next[i] = (next[i] - '0' + j + 10) % 10 + '0';
            if (next == target) return steps;
            if (dead.count(next) || visited.count(next)) continue; 
            q.push(next);
            visited.insert(next);
          }
      }
    }
    
    return -1;
  }
};



```

:::
::: code-group-item python

``` python

```
::::

### 分析
- 時間複雜度：$\mathcal{O}(8*10^4)$

- 空間複雜度：$\mathcal{O}(10^4+Deadend)$

